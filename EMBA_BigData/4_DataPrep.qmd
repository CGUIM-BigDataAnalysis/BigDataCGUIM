---
title: "4. Data Preprocessing"
author: "Yi-Ju Tseng"
format:
  revealjs:
    slide-number: c/t
    show-slide-number: all
editor: visual
---

## 資料分析步驟

-   資料匯入
-   **資料清洗處理**
-   資料分析
-   資料呈現與視覺化

## 資料清洗與處理

-   Tidy Data
-   資料型態轉換處理
-   文字字串處理
-   子集Subset
-   排序
-   資料組合
-   長表轉寬表
-   遺漏值處理


## 前置作業

為了成功從https (加密封包傳輸)下載資料，首先取消證書驗證

```{python}
#| echo: true
import ssl
ssl._create_default_https_context = ssl._create_unverified_context
```

## Tidy Data

type:sub-section

Each column is a variable. Each row is an observation.

-   一個欄位（Column）內只有一個數值，最好要有凡人看得懂的Column Name
-   不同的觀察值應該要在不同列（Row）
-   一張表裡面，有所有分析需要的資料
-   如果一定要多張表，中間一定要有index可以把表串起來
-   One file, one table

# 資料型態轉換處理

## 資料型態轉換處理

包括**資料型態檢查**與**資料型態轉換**

Data Types 資料型態

-   **文字 (text, string, character)**
-   **數值 (numeric)**
-   **布林變數 (Boolean, logic)**
-   **日期 (date)**


## Check Data Type

使用`type()`函數可查看資料結構

```{python}
#| echo: true
import pandas as pd
df1 = pd.DataFrame({"ID":[1, 2, 3, 4],
                    "Name":["Tom","Emma","Ryan","Amy"]})
type(df1)
```

```{python}
#| echo: true
dist1 = {"id":1, "name":"Ryan", "School":"CGU"}
type(dist1)
```

## 資料型態檢查 - isinstance

使用`isinstance()`函數檢查資料型態，回傳布林變數，若為**真**，回傳**TRUE**

-   是否為**數字** `isinstance(變數名稱,(int,float))`
-   是否為**文字** `isinstance(變數名稱,str)`
-   是否為**布林變數** `isinstance(變數名稱,bool)`

```{python}
#| echo: true
num = 100
isinstance(num,int)
```

```{python}
#| echo: true
isinstance(num,float)
```

```{python}
#| echo: true
isinstance(num,(int,float))
```


```{python}
#| echo: true
text = "100"
isinstance(text,(int,float))
```

```{python}
#| echo: true
text = "100"
isinstance(text,str)
```


# 資料型態轉換 - 複習Python 101

使用`int()`, `float()`, `str()`函數轉換型態

-   轉換為**整數** `int(變數名稱)`
-   轉換為**浮點數** `float(變數名稱)`
-   轉換為**文字** `str(變數名稱)`

```{python}
#| echo: true
cha = "100"
cha_int = int(cha)
type(cha_int)
```

## 資料型態轉換 - as.

若無法順利完成轉換，會出現錯誤訊息

```{python}
#| echo: true
int("abc")
```

## Hands-on 資料型態轉換練習

回想起台積電的資料

```{python}
#| echo: true
import requests
from bs4 import BeautifulSoup
StockUrl = "https://tw.stock.yahoo.com/quote/2330"
res = requests.get(StockUrl)
soup = BeautifulSoup(res.text, "html.parser")
price_type = soup.select(".price-detail-item .C\(\#232a31\)")
price_detail = soup.select(".price-detail-item .Fw\(600\)")
type_list=[]
price_list=[]
for i in price_type:
  type_list.append(i.get_text())
for i in price_detail:
  price_list.append(i.get_text())
import pandas as pd
price_df = pd.DataFrame({"Type" : type_list, "Price":price_list})
```

## Hands-on 資料型態轉換練習

回想起台積電的資料

```{python}
price_df
```

## Hands-on 資料型態轉換練習

- Price欄位的資料型態是？
- 如何將Price欄位轉換成數字？
- **Hint**: 先做該欄位第一個數字，以此類推


# 文字字串處理

## 文字字串處理

-   基本查詢
-   基本處理
-   搜尋字串


## 基本查詢

-   字串長度 `len(變數名稱)`
-   字串內包含某字的個數 `.count(某字)`

```{python} 
#| echo: true
str_ex = "Hello World"
len(str_ex)
```
```{python} 
#| echo: true
str_ex.count("o")
```

## 基本處理

-   切割 `.split()` **Split**
-   子集 `字串變數[:]` **sub string**, **Slice**
-   大小寫轉換 `.upper()` `.lower()`
-   兩文字連接 `+` `.join(字串清單list)`
-   文字取代 `.replace(舊值,新值)` **substitute**
-   前後空白去除 `.strip(字元,預設空白)` **trim**

## 基本處理-切割

`字串變數.split(用什麼符號切割)`

```{python} 
#| echo: true
str_ex = "Hello World"
str_ex.split(" ")
```

## 基本處理-子集（切一小段）

`字串變數[開始位置:結束位置]`（不包含結束位置）
```{python} 
#| echo: true
str_ex
```
```{python} 
#| echo: true
str_ex[1:5]
```

## 基本處理-大小寫轉換

-   `字串變數.upper()`
-   `字串變數.lower()`

```{python} 
#| echo: true
str_ex.upper()
```
```{python} 
#| echo: true
str_ex.lower()
```

## 基本處理-兩文字連接

-   字串1`+`字串2 
-   `字串變數.join(字串清單list)`，字串變數為字串間隔

```{python} 
#| echo: true
"Hello" + "World"
str_list = ["桃園市","龜山區","文化一路"]
space = " "
space.join(str_list)
```

## 基本處理-文字取代

`字串變數.replace(舊值,新值)` **substitute**

```{python} 
#| echo: true
str_ex.replace("o","0")
```


## 基本處理-前後空白去除


`字串變數.strip(字元,預設空白)` **trim**

```{python} 
#| echo: true
space_ex = "    CGU.   "
space_ex.strip()
```
```{python} 
#| echo: true
dot_ex = "CGU."
dot_ex.strip(".")
```
## Hands-on 字串基本處理

回想起台積電的資料

```{python}
#| echo: true
import requests
from bs4 import BeautifulSoup
StockUrl = "https://tw.stock.yahoo.com/quote/2330"
res = requests.get(StockUrl)
soup = BeautifulSoup(res.text, "html.parser")
price_type = soup.select(".price-detail-item .C\(\#232a31\)")
price_detail = soup.select(".price-detail-item .Fw\(600\)")
type_list=[]
price_list=[]
for i in price_type:
  type_list.append(i.get_text())
for i in price_detail:
  price_list.append(i.get_text())
import pandas as pd
price_df = pd.DataFrame({"Type" : type_list, "Price":price_list})
```

## Hands-on 字串基本處理

回想起台積電的資料

```{python}
price_df
```

## Hands-on 字串基本處理

-   請把Price欄位中的%符號移除，並在相對應的Type欄位加上%符號
-   請把Price欄位中,移除，再將整個Price欄位轉為數字


## 搜尋字串

-   使用`==`, `in`完整比對
-   **有分大小寫**


```{python} 
#| echo: true
str1="CGU"
str2="cgu"
str3="CGU"
str1 == str2
```
```{python} 
#| echo: true
str1 == str3
```
```{python} 
#| echo: true
str1 in ["CGUST","NTU","NYCU"]
```
```{python} 
#| echo: true
str1 in ["CGUST","CGU","NYCU"]
```
## 搜尋字串 - 是否包含某字

-   `字串變數.find(搜尋字串)`，回傳index，回傳-1表示沒有
-   `字串變數.count(計算字串)`，回傳個數

```{python} 
#| echo: true
str1
```
```{python} 
#| echo: true
str1.find("C")
```
```{python} 
#| echo: true
str2
```
```{python} 
#| echo: true
str2.find("C")
```
```{python} 
#| echo: true
str2.count("C")
```

## 搜尋字串 - re套件

使用正規表示式搜尋文字，需載入`re`套件(不用安裝)

- `re.match("找尋目標","在哪找")`找字串是否為找尋目標開頭
- `re.search("找尋目標","在哪找")`找字串是否包含為找尋目標

```{python} 
#| echo: true
import re
re.match("A","Alex")
```
```{python} 
#| echo: true
re.match("l","Alex")
print(re.match("l","Alex"))
```
```{python} 
#| echo: true
re.search("l","Alex")
```

## 搜尋字串 - 基本正規表示式

-   `re.search("找尋目標","在哪找")`，目標可以是正規表示式
-   `^`開頭
-   `$`結尾

```{python} 
#| echo: true
re.search("^l","Alex")
print(re.search("^l","Alex"))
```
```{python} 
#| echo: true
re.search("x$","Alex")
```


## Hands-on 搜尋字串

## 搜尋字串 - 基本正規表示式

-   `*`0-n個
-   `+`1-n個
-   `[]`包含某些字
-   `d`包含0-9...
-   [參考資料](https://selflearningsuccess.com/python-regex/#%E5%90%84%E7%A8%AE%E5%B9%AB%E5%8A%A9%E4%BD%A0%E6%AF%94%E5%B0%8D%E7%9A%84%E5%B7%A5%E5%85%B7)

```{python} 
#| echo: true
re.search("[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]+","yjtseng@nycu.edu.tw")
```

```{python} 
#| echo: true
re.match("x$","Alex")
```

# 子集Subset

## 子集Subset - 一維資料

type:sub-section

之前有介紹使用`[ ]`取出單一或多個元素的方法

```{python} 
#| echo: true
letters ##R語言內建資料之一
letters[1] ##取出letters向量的第一個元素
```

# 子集Subset - 一維資料

也可以用“負號”去掉不要的資料

```{python} 
#| echo: true
letters[c(1,3,5)] ##取出letters向量的第1,3,5個元素
letters[c(-1,-3,-5)] ##取出letters向量除了第1,3,5個元素之外的所有元素
```

# 子集Subset - 一維資料

若想要快速取得一向量的開頭與結尾元素，可使用`head()`和`tail()`函數

```{python} #| echo: true
head(letters,5) ##取出letters向量的前五個元素
tail(letters,3) ##取出letters向量的後三個元素
```

# 子集Subset - 二維資料

type:sub-section - 可針對列(Row)和行(Column)做子集 - 使用`[ ]`，但因應二維資料的需求，以`,`分隔列與行的篩選條件 - 資料篩選原則為**前Row,後Column**，**前列,後行** - 若不想篩選列，則在`,`前方保持**空白**即可。 - 篩選方式可輸入**位置(index)**、**欄位名稱**或輸入**布林變數(TRUE/FALSE)** - 輸入位置: `dataFrame[row index,column index]` - 輸入布林變數: `dataFrame[c(T,F,T),c(T,F,T)]` - 輸入欄位名稱: `dataFrame[row name,column name]` - 最後常用的是dplyr中的`select()`和`filter()`功能

# 子集Subset - head()

若想要快速取得資料框的前幾列(Row)或後幾列，也可使用`head()`和`tail()`函數

```{r eval=F}
head(iris,5) ##取出iris資料框的前五列
```

```{r echo=F}
knitr::kable(head(iris,5)) 
```

# 子集Subset - tail()

若想要快速取得資料框的前幾列(Row)或後幾列，也可使用`head()`和`tail()`函數

```{r eval=F}
tail(iris,3) ##取出iris資料框的後三列
```

```{r echo=F}
knitr::kable(tail(iris,3))
```

# 資料組合

type:sub-section

有時需要在資料框新增一列，或新增一行

-   Row 列的組合 `rbind()`
-   Column 行的組合 `cbind()`

`rbind()`和`cbind()`的參數可以是向量，也可以是資料框

# 資料組合 - rbind()

使用向量做資料整合範例:

```{python} #| echo: true
rbind(c(1,2,3), #第一列
      c(4,5,6)  #第二列
      ) 
```

# 資料組合 - rbind()

使用資料框與向量做資料整合範例:

```{r warning=F}
irisAdd<-rbind(iris, #資料框
      c(1,1,1,1,"versicolor")  #新增一列
      ) 
```

```{r eval=F}
tail(irisAdd,2)
```

```{r echo=F}
knitr::kable(tail(irisAdd,2)) 
```

# 資料組合 - cbind()

使用向量做資料整合範例:

```{python} #| echo: true
cbind(c(1,2,3), #第一行
      c(4,5,6)  #第二行
      ) 
```

# 資料組合 - cbind()

使用資料框與向量做資料整合範例:

```{r warning=F}
irisAdd<-cbind(iris, #資料框
      rep("Add",nrow(iris))  #新增一行
      ) 
```

```{r eval=F}
tail(irisAdd,1)
```

```{r echo=F}
knitr::kable(tail(irisAdd,1)) 
```

# 資料結合 (Join)

除了按照行列順序的組合外，更常有的情形是依照某個欄位的值作為結合依據，如：

-   用學號把以下兩個資料框結合成一個資料框
    -   學號與姓名資料框
    -   學號與宿舍床位資料框
-   用縣市名稱與年度將人口資料與醫療資源資料結合

# 資料結合 (Join)

原生的R環境可以用`merge()`函數將資料框結合，使用方法為`merge(資料框1,資料框2,by="結合依據欄位")`

```{python} #| echo: true
nameDF<-data.frame(ID=c(1,2,3,4,5),
                  Name=c("Amy","Bob","Chris","David","Emma"))
scoreDF<-data.frame(ID=c(1,2,4),
                  Score=c(60,90,50))
```

# 資料結合 (Join)

```{r, eval=F}
nameDF
```

```{r, echo=F}
knitr::kable(nameDF)
```

------------------------------------------------------------------------

```{r, eval=F}
scoreDF
```

```{r, echo=F}
knitr::kable(scoreDF)
```

# 資料結合 (Join) 更有效率的做法

`dplyr`套件提供更有效率的資料結合方法，包括:

-   inner_join()：保留有對應到的資料
-   left_join()：保留左邊資料框的所有資料
-   right_join()：保留右邊資料框的所有資料
-   full_join()：保留所有資料
-   semi_join()
-   anti_join()

# 資料結合 - inner_join()

只保留兩張表都有的列 使用方法 `inner_join(x, y, by = )`

```{python} #| echo: true
library(dplyr)
inner_join(nameDF,scoreDF,by="ID")
```

# 資料結合 - left_join()

保留左邊的表所有的列 使用方法 `left_join(x, y, by = )`

```{python} #| echo: true
library(dplyr)
left_join(nameDF,scoreDF,by="ID")
```

# 資料結合 - right_join()

保留右邊的表所有的列 使用方法 `right_join(x, y, by = )`

```{python} #| echo: true
library(dplyr)
right_join(nameDF,scoreDF,by="ID")
```

# 資料結合 - full_join()

保留所有的列 使用方法 `full_join(x, y, by = )`

```{python} #| echo: true
library(dplyr)
full_join(nameDF,scoreDF,by="ID")
```

# 資料結合 - semi_join()

留下左邊的ID也有出現在右邊的表的列，右表資料不會輸出 使用方法 `semi_join(x, y, by = )`

```{python} #| echo: true
library(dplyr)
semi_join(nameDF,scoreDF,by="ID")
```

# 資料結合 - anti_join()

留下左邊的ID沒有出現在右邊的表的列，右表資料不會輸出 使用方法 `anti_join(x, y, by = )`

```{python} #| echo: true
library(dplyr)
anti_join(nameDF,scoreDF,by="ID")
```

# 資料結合練習

type:alert

-   下載[COVID-19案例數資料](https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv)
-   下載[COVID-19死亡數資料](https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv)
-   分別讀入兩個csv檔
-   依照Province/State,Country/Region,Lat,Long四個欄位，將兩張表格結合，只留下有對應到的資料
-   請問結合後的資料有幾列？

# 長表與寬表

type:sub-section

-   在資料處理的過程中，常因各種需求，需要執行長寬表互換的動作
-   `tidyr` package提供完整的轉換功能
    -   寬表轉長表 `pivot_longer(資料框/寬表,cols=需要轉換成長表的欄位)`
    -   長表轉寬表 `pivot_wider(資料框/長表,names_from=需要轉換成寬表的欄位)`

# 長表與寬表

原來的`airquality`資料框中，有Ozone, Solar.R, Wind, Temp, Month, Day等六個欄位 (Column)，屬於寬表

```{r eval=F}
head(airquality,3)
```

```{r echo=F}
knitr::kable(head(airquality,3)) 
```

# 寬表轉長表 pivot_longer（）

-   保留Month和Day兩個欄位
-   消滅Ozone, Solar.R, Wind, Temp
-   將其他欄位的名稱整合至name欄位，數值整合至value欄位

```{python} #| echo: true
library(tidyr)
##欄位需要保留"Month","Day"
##欄位需要消滅"Ozone","Solar.R","Wind","Temp" -> 換轉換成"name"
airqualityLong<-
  pivot_longer(airquality,
               cols = c("Ozone","Solar.R","Wind","Temp")) 
```

```{r eval=F}
head(airqualityLong)
```

```{r echo=F}
knitr::kable(head(airqualityLong)) 
```

# 寬表轉長表 pivot_longer（）

-   保留Month和Day兩個欄位
-   消滅Ozone, Solar.R, Wind, Temp
-   將其他欄位的名稱整合至name欄位，數值整合至value欄位

```{python} #| echo: true
library(tidyr)
##欄位需要保留"Month","Day"
##欄位需要消滅"Ozone","Solar.R","Wind","Temp" -> 換轉換成"name"
airqualityLong<-
  pivot_longer(airquality,
               cols = c(-"Month",-"Day")) 
```

```{r eval=F}
head(airqualityLong)
```

```{r echo=F}
knitr::kable(head(airqualityLong)) 
```

# 長表轉寬表 pivot_wider（）

-   `airqualityLong`資料框中，剩下Month, Day, name, value等四個欄位 (Column)，屬於長表
-   variable欄位的值轉換為新欄位，並將value欄位填回新增的欄位

```{python} #| echo: true
##增加欄位由name定義
airqualityWide<-
  pivot_wider(airqualityLong, 
              names_from="name") 
```

```{r eval=F}
head(airqualityWide)
```

```{r echo=F}
knitr::kable(head(airqualityWide))
```

# 遺漏值處理

type:sub-section

-   遺漏值(Missing Value)常常出現在真實資料內，在數值運算時常會有問題
-   最簡單的方法是將有缺值的資料移除

# 遺漏值處理 is.na()

如資料為向量，可使用`is.na()`來判斷資料是否為空值`NA`，若為真`TRUE`，則將資料移除。

```{python} #| echo: true
naVec<-c("a","b",NA,"d","e")
is.na(naVec)
naVec[!is.na(naVec)] ##保留所有在is.na()檢查回傳FALSE的元素
```

# 遺漏值處理 complete.cases()

若資料型態為資料框，可使用`complete.cases`來選出完整的資料列，如果資料列是完整的，則會回傳真TRUE

```{r eval=F}
head(airquality,5)
```

```{r echo=F}
knitr::kable(head(airquality,5))
```

```{python} #| echo: true
complete.cases(airquality) 
```

# 遺漏值處理 complete.cases()

若資料型態為資料框，可使用`complete.cases`來選出完整的資料列，如果資料列(row)是完整的，則會回傳真TRUE

```{r eval=F}
head(airquality[complete.cases(airquality),]) ##保留所有在complete.cases()檢查回傳TRUE的元素
```

```{r echo=F}
knitr::kable(head(airquality[complete.cases(airquality),]))
```
